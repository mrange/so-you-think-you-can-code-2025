/**
 * GLSL Shader Module: sweet_dreams_shader.ts
 *
 * Contains the fragment shader code for the GPU audio synthesis.
 * The core DSP logic is defined here as a single GLSL string, exported for use
 * by the GPUSynth class.
 */
export const SWEET_DREAMS_SHADER: string = /*glsl*/`#version 300 es
#ifdef GL_ES
  precision highp int;
  precision highp float;
#endif
// Time in seconds for the start of the current buffer chunk
uniform float bufferTime;
// Total samples per second (e.g., 44100.0)
uniform float sampleRate;
// Dimensions of the rendering target (e.g., vec2(128.0, 64.0))
uniform vec2 resolution;
// Stereo channel identifier (0.0 for Left, 1.0 for Right)
uniform float channel;

out vec4 fragColor;

#define PI acos(-1.)
#define TAU acos(-1.)*2
float bpm = 126.0;
float bps = 2.1; // Beats per second

// Converts a MIDI note number (n) to frequency (Hz)
float noteToFreq (float n) {
  // A4 (note 49 in this scheme) = 440 Hz
  return pow(2.0, (n - 49.0) / 12.0) * 440.0;
}

// Implementation of an ADSR envelope (Attack, Decay, Sustain, Release)
float adsr(float tabs, vec4 env, float start, float duration) {
  float t = tabs - start;
  float sustain = env[2];
  float t1 = env[0];
  float t2 = t1 + env[1];
  float t3 = max(t2, duration);
  float t4 = t3 + env[3];
  
  if (t < 0.0 || t > t4) return 0.0;
  
  // Attack phase: smooth fade-in from 0 to 1
  if(t <= t1) {
    return smoothstep(0.0, t1, t);
  } 
  // Decay phase: smooth fade-down from 1 to Sustain level
  else if(t <= t2) {
    float f = smoothstep(t2, t1, t);
    return sustain + f * (1.0 - sustain);
  } 
  // Sustain phase: holds at Sustain level
  else if(t <= t3) {
    return sustain;
  } 
  // Release phase: smooth fade-out from Sustain level to 0
  else {
    return sustain * smoothstep(t4, t3, t);
  }
}

// Pseudo-random number generator for noise (e.g., hi-hat)
float rand(float co){
  return fract(sin(dot(vec2(co),vec2(12.9898,78.233))) * 43758.5453);
}

// Sine Wave (pure tone)
float sine(float t, float x){
  return sin(2.0 * PI * t * x);
}

// Triangle Wave (odd harmonics, hollow sound)
float tri(float t, float x) {
  return abs(1.0 - mod((2.0 * t * x), 2.0)) * 2.0 - 1.0;
}

// Sawtooth Wave (rich harmonics, bright sound)
float saw(float t, float x) {
  return fract(2.0 * t * x) * 2.0 - 1.0;
}

// Clipping/Saturation effect: limits amplitude to introduce distortion
float sat(float t, float amp) {
  return max(-amp, min(t, amp));
}

// Kick Drum/Beat sound using a pitched triangle wave that decays rapidly
float beat (float t, float s, float f) {
  t = min(t, s);
  // smoothstep creates a quick pitch bend down to 0, simulating a drum
  float r = tri(t, f * smoothstep(2.0*s, 0.0, t)); 
  return r;
}

// Multi-waveform additive synth voice for the bassline/melody
float synth (float t, float f) {
  // Add phase modulation for stereo movement (mixed by 'channel')
  t += mix(0.2, 0.6, channel) * sin(t * 2.0) / f;
  
  // Combine Triangle (fundamental), Saturated Sine, and Sawtooth waves
  return 0.3 * tri(t, f / 2.0) +
         sat(0.8 * sine(t, f / 4.0 + 0.2), 0.2) +
         0.2 * saw(t, f / 4.0) +
         0.2 * saw(t, f / 4.0 + mix(0.3, 0.2, channel));
}

// The sequenced melody (Sweet Dreams Riff)
float sweetDreamSynth (float t) {
  // C2 C2 C3 C4 d3 d4 C3 C4 g2 g2 g3 C4 G2 G2 G3 C4
  int notes[16];
  notes[0]=24; notes[1]=24; notes[2]=36; notes[3]=48;
  notes[4]=39; notes[5]=51; notes[6]=36; notes[7]=48;
  notes[8]=32; notes[9]=32; notes[10]=44; notes[11]=48;
  notes[12]=31; notes[13]=31; notes[14]=46; notes[15]=48;

  float m = mod(t * bps * 2.0, 16.0);
  float sound = 0.0;
  
  // Additive synthesis: sum up all 16 notes with their respective envelopes
  for (int i=0; i<16; ++i) {
    // Pitch transpose logic (alternates octave every 16 beats)
    float pitch_factor = (mod(t * bps * 2.0, 32.0) > 16.0 ? 1.0 : 2.0); 
    
    sound += synth(t, pitch_factor * noteToFreq(float(notes[i]))) * adsr(m, vec4(0.1, 0.2, 0.7, 0.8), float(i), 0.6);
  }
  return sound;
}


// The main DSP mixer function
float dsp(float t) {
  float nobeatsfreq = 6.0;
  
  // Conditional beat drop: the beat/hat stops for a section of the loop
  float beat_mix = mod(t * bps * 2.0, nobeatsfreq * 16.0) / 16.0 < nobeatsfreq - 2.0 ?
    (
      // Beat/Kick Drum
      0.6 * beat(mod(t * bps, 2.0), 0.2, 60.0) * mix(0.6, 1.0, channel) +
      // Hi-Hat (noise generated by rand, shaped by ADSR)
      0.3 * adsr(mod(t * bps, 2.0), vec4(0.02, 0.05, 0.7, 1.0), 1.0, 0.1) * rand(t) * mix(0.8, 1.0, channel)
    ) : 0.0;
    
  return beat_mix +
    // Melody
    0.4 * sweetDreamSynth(t) * mix(1.0, 0.8, channel);
}

void main(){
  
    // Calculate precise time for the current fragment/sample block.
    // We compute 4 samples (R, G, B, A) per fragment.
    float t = bufferTime + 4.0 * (gl_FragCoord.y * resolution.x + gl_FragCoord.x) / sampleRate;
    
    // Generate 4 consecutive audio samples
    vec4 r = vec4(dsp(t),dsp(t + 1.0/sampleRate), dsp(t + 2.0/sampleRate), dsp(t + 3.0/sampleRate)); 
    
    // Map audio range [-1.0, 1.0] to color range [0.0, 1.0] for the GPU output buffer
    fragColor = (r + 1.0) / 2.0;
}
`;